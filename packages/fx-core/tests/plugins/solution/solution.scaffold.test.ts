// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import chai from "chai";
import chaiAsPromised from "chai-as-promised";
import { it } from "mocha";
import { TeamsAppSolution } from " ../../../src/plugins/solution";
import { ok, SolutionContext, Platform, v2, Inputs } from "@microsoft/teamsfx-api";
import * as sinon from "sinon";
import fs from "fs-extra";
import { environmentManager, setTools } from "../../../src";
import {
  BotOptionItem,
  HostTypeOptionAzure,
  HostTypeOptionSPFx,
  MessageExtensionItem,
  TabOptionItem,
} from "../../../src/plugins/solution/fx-solution/question";
import _ from "lodash";
import path from "path";
import { newProjectSettings } from "../../../src";
import { getQuestionsForScaffolding } from "../../../src/plugins/solution/fx-solution/v2/getQuestions";
import { MockTools, randomAppName } from "../../core/utils";
import { assert } from "console";
import { TestHelper } from "./helper";
import {
  botPlugin,
  fehostPlugin,
  simpleAuthPlugin,
  spfxPlugin,
  localdebugPlugin,
  appStudioPlugin,
  TestFilePath,
  aadPlugin,
  identityPlugin,
} from "../../constants";
import mockedEnv from "mocked-env";
import * as os from "os";
chai.use(chaiAsPromised);
const expect = chai.expect;

describe("Solution scaffold() reading valid manifest file", () => {
  const mocker = sinon.createSandbox();
  let solution: TeamsAppSolution;
  let mockedCtx: SolutionContext;
  let mockedEnvRestore: () => void;

  beforeEach(async () => {
    mockedEnvRestore = mockedEnv({
      __TEAMSFX_INSIDER_PREVIEW: "true",
    });
    await fs.ensureDir(TestHelper.rootDir);
    solution = new TeamsAppSolution();
    mockedCtx = TestHelper.mockSolutionContext();
    mockedCtx.projectSettings!.solutionSettings = {
      hostType: HostTypeOptionAzure.id,
      name: "azure",
      activeResourcePlugins: [
        aadPlugin.name,
        fehostPlugin.name,
        simpleAuthPlugin.name,
        identityPlugin.name,
      ],
      capabilities: [TabOptionItem.id],
    };

    TestHelper.mockScaffoldThatAlwaysSucceed(fehostPlugin);
    TestHelper.mockScaffoldThatAlwaysSucceed(simpleAuthPlugin);
    TestHelper.mockScaffoldThatAlwaysSucceed(identityPlugin);
    TestHelper.mockScaffoldThatAlwaysSucceed(aadPlugin);
    TestHelper.mockScaffoldThatAlwaysSucceed(localdebugPlugin);
    TestHelper.mockScaffoldThatAlwaysSucceed(appStudioPlugin);
    TestHelper.mockScaffoldThatAlwaysSucceed(botPlugin);
    mocker.stub(environmentManager, "listRemoteEnvConfigs").resolves(ok(["default"]));
    mocker.stub(environmentManager, "listAllEnvConfigs").resolves(ok(["default", "local"]));
    TestHelper.mockedFehostGenerateArmTemplates(mocker);
    TestHelper.mockedIdentityGenerateArmTemplates(mocker);
    TestHelper.mockedAadGenerateArmTemplates(mocker);
    TestHelper.mockedSimpleAuthGenerateArmTemplates(mocker);
    TestHelper.mockedBotGenerateArmTemplates(mocker);
  });

  afterEach(async () => {
    mockedEnvRestore();
    await fs.remove(TestHelper.rootDir);
    mocker.restore();
  });

  it("should work for happy path with only tab", async () => {
    const result = await solution.scaffold(mockedCtx);
    expect(result.isOk()).to.be.true;
  });

  it("should work and generate README.md for happy path with tab and bot", async () => {
    // Arrange
    mockedCtx.projectSettings!.solutionSettings = {
      hostType: HostTypeOptionAzure.id,
      name: "azure",
      activeResourcePlugins: [
        aadPlugin.name,
        fehostPlugin.name,
        simpleAuthPlugin.name,
        identityPlugin.name,
        botPlugin.name,
      ],
      capabilities: [TabOptionItem.id, BotOptionItem.id],
    };

    // Act
    const result = await solution.scaffold(mockedCtx);

    // Assert
    expect(result.isOk()).to.be.true;
    expect(await fs.pathExists(path.join(TestHelper.rootDir, TestFilePath.autoGeneratedReadme))).to
      .be.true;
  });

  it("should work and generate README.md for happy path with tab and msgext", async () => {
    // Arrange
    mockedCtx.projectSettings!.solutionSettings = {
      hostType: HostTypeOptionAzure.id,
      name: "azure",
      activeResourcePlugins: [
        aadPlugin.name,
        fehostPlugin.name,
        identityPlugin.name,
        botPlugin.name,
      ],
      capabilities: [TabOptionItem.id, MessageExtensionItem.id],
    };

    // Act
    const result = await solution.scaffold(mockedCtx);

    // Assert
    expect(result.isOk()).to.be.true;
    expect(await fs.pathExists(path.join(TestHelper.rootDir, TestFilePath.autoGeneratedReadme))).to
      .be.true;
  });

  it("should work and not generate arm template when project does not require Azure services", async () => {
    // Arrange
    mockedCtx.projectSettings!.solutionSettings = {
      hostType: HostTypeOptionSPFx.id,
      name: "spfx",
      activeResourcePlugins: [spfxPlugin.name],
      capabilities: [TabOptionItem.id],
    };
    TestHelper.mockScaffoldThatAlwaysSucceed(spfxPlugin);

    // Act
    const result = await solution.scaffold(mockedCtx);

    // Assert
    expect(result.isOk()).to.be.true;
  });

  it("getQuestionsForScaffolding", async () => {
    const tools = new MockTools();
    setTools(tools);
    const contextv2: v2.Context = {
      userInteraction: tools.ui,
      logProvider: tools.logProvider,
      telemetryReporter: tools.telemetryReporter!,
      cryptoProvider: tools.cryptoProvider!,
      permissionRequestProvider: tools.permissionRequestProvider!,
      projectSetting: newProjectSettings(),
    };
    const inputs: Inputs = {
      platform: Platform.CLI,
      projectPath: path.join(os.tmpdir(), randomAppName()),
    };
    const res = await getQuestionsForScaffolding(contextv2, inputs);
    assert(res.isOk());
  });
});
